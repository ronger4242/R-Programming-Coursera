#Loop function: the Apply family
#lapply: Loop over a list and evaluate a function on each element
#sapply: Same as lapply but try to simplify the result
#apply: Apply a function over the margins of an array
#tapply: Apply a function over subsets of a vector
#mapply: Multivariate version of lapply
#vapply: tell R what we want to return.
vapply(flags, class, character(1)) #the result should be character vector of length 1.

#lapply and sapply: 3 arguments:1)a list X; 2) a function FUN; 3)other arguments ...
x<-list(a=1:5,b=rnorm(10))
lapply(x,mean) # it returns a list.

x<-1:4
lapply(x,runif) #runif: generate uniform random numbers.
#runif (1), runif(2), runif(3),runif(4)

#the default of the range for the runif function is 0-1. To change it, we need to specify the min and max.
x<-1:4
lapply(x, runif, min=0,max=10)

x<-list(a=matrix(1:4,2,2),b=matrix(1:6,3,2))
x
#let's extract the first columns from both matrices.
elt<-function(x){
    x[,1]
}
lapply(x,elt)

#or we can write anonymous function(only works in the main function) within the lapply function:
lapply(x,function(elt) elt[,1])

#sapply: same as lapply, but the results are simpler:
    #If the result is a list where every element is length 1, then a vector is returned
    #If the result is a list where every element is a vector of the same length (> 1), a matrix is returned.
    #If it cannot figure things out, a list is returned
x<-list(a=1:5,b=rnorm(10))
sapply(x,mean) #returns a vector of two means.

#apply: often used to evaluate a function over the margines of an array.
    #rows and columns of a matrix
    #apply(x,margin, FUN) #margin: an integer vector indicating which margins should be retained.
x<-matrix(rnorm(200),20,10)
apply(x,1,mean) #means of rows
apply(x,2,mean) #means of columns

#There are also special functions to calculate the means and sums for rows and columns:
  #rowSums, rowMeans, colSums, colMeans: faster than using apply

#calculate the 25th and 75th percentile of the rows
x<-matrix(rnorm(200),20,10)
apply(x,1,quantile,probs=c(0.25,0.75))

#mapply: it is like the multivariate version of lapply, sapply.
     #It applies a function in a parallel over a set of arguments.
#instead of typing list(rep(1:4),rep(2:3),rep(3:2),rep(4:1))
mapply(rep,1:4,4:1)

noise<-function(n,mean,sd){
    rnorm(n,mean,sd)
}

noise(5,1,2)
#if I want to get 1 random number with mean 1, 2 random numbers with mean 2...
mapply(noise,1:5,1:5,2)
mapply(rnorm,1:5,1:5,2)
#it is the same as: list(noise(1,1,2),noise(2,2,2),noise(3,3,2),noise(4,4,2),noise(5,5,2))


#tapply(x,INDEX, FUN, simplify=T):apply a function over subsets of a vector. #table apply
  #gl(n,k,length=n*k): generate factors by specifying the pattern of their levels.
x<-c(rnorm(10),runif(10),rnorm(10,1))
x
class(x)
#divde them into three groups, then take means for each group. We need an index variable.
f<-gl(3,10)
f
tapply(x,f,mean)
tapply(x,f,range) #get min and max of each group
#if we do not simplify the results, the returns will be a list.
tapply(x,f,mean,simplify=F)
tapply(flags$animate, flags$landmass, mean)
#landmass is the grouping variable, group animate based on landmass and calculate mean.
#split():takes a vector and splits it into gropus determined by a factor.
x<-c(rnorm(10),runif(10),rnorm(10,1))
f<-gl(3,10)
split(x,f) #returns a list
#if we want to do something with the list, use lapply or sapply:
lapply(split(x,f),mean) #equals to tapply(x,f,mean)

#splitting a dataframe
library(datasets)
head(airquality)
#calculate the means of ozne, solar.R, wind within each Month.
s<-split(airquality,airquality$Month) #split(data, grouping factor)
s
col_mean<-function(x){
    colMeans(x[,c("Ozone","Solar.R","Wind")])
}
lapply(s,col_mean)
#or combine them together
lapply(s, function(x) colMeans(x[,c("Ozone","Solar.R","Wind")]))

OSW_means<-function(x){
    colMeans(x[,c("Ozone","Solar.R","Wind")],na.rm=T)
} 
lapply(s,OSW_means) #s is not a matrix, so we cannot use OSW_means(s)
sapply(s,OSW_means) #simplify the results and returns a matrix
s_1<-as.matrix(s[[1]]) #convert the first element of s into a matrix, then we can apply the functions.
s_1
class(s_1)
colMeans(s_1,na.rm=T)
OSW_means(s_1)

#splitting more than one level
x<-rnorm(10)
f1<-gl(2,5)
f2<-gl(5,2)
f1
f2
interaction(f1,f2) #combination of f1 and f2
split(x,list(f1,f2)) #it will automaticlaly generate the interaction function.
#equals to:
split(x,interaction(f1,f2))
#drop the empty levels:
split(x,list(f1,f2),drop=T)

#Debugging
#message: A generic notification/diagnostic message produced by the message function;
#execution of the function continues
#warning: An indication that something is wrong but not necessarily fatal; execution of the
#function continues; generated by the warning function
#error: An indication that a fatal problem has occurred; execution stops; produced by the stop
#function
#condition: A generic concept for indicating that something unexpected can occur; programmers
#can create their own conditions

printmessage <- function(x) {
    if(is.na(x))
        print("x is a missing value")
    else if(x > 0)
        print("x is greater than zero")
    else
        print("x is less than or equal to zero")
    invisible(x) #invisible() prevent auto-printing x
}

printmessage(x)
printmessage(1)
printmessage(NA)

#1.traceback(): track back the most recent error
mean(xx)
traceback()

lm(yy~xx)
traceback() #the error happens 7 level deep.

#debug
debug(lm)
lm(yy~xx) #then press n, n, n(next next next) to figure out where the error is.
